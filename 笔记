cout cerr cin clog:四种标准输入输出流,cerr不使用缓存,直接显示.

左值和右值: 左值(在赋值语句中可左可右),右值(在赋值语句中只可右), 函数传递值或函数返回值的时候需要讨论.

变量名:必须以字母或下划线开头,可以由字母、数字和下划线组成.

定义对象:直接初始化int ival(1024);复制初始化int ival=1024.

class成员默认指定为private; struct成员默认指定为public.

通过基类指针指向派生类对象,调用函数时:
1.若是非虚函数,直接执行基类的函数
2.若是虚函数,若派生类重写这个函数,则调用派生类的函数,否则调用基类的.
3.若是纯虚函数(纯虚类不能实例化),强制调用派生类中的函数,派生类必须实现纯虚函数.

私有继承是has a,但是尽量使用组合.
共有继承是is a.

虚函数表在构造函数中初始化，所以构造函数不能是虚函数。
为了释放派生类的资源，基类的析构函数必须虚函数，防止覆盖派生类的析构函数。

gcc 编译过程：
预处理---> 编译，生成汇编代码--->  汇编,生成机器码或目标码 ---> 链接（链接静态库，动态链接库）生成可执行文件
链接静态库的方式是直接复制粘贴到可执行文件中， 动态库是在运行过程中加载。
-E (产生stdout的输出)  -s (产生汇编代码) -c 生成机器码或目标代码文件  -o 生成可执行文件  -save-temps 生成前面所有的文件 -Wall 输出警告信息
-l 头文件路径 -L 库文件路径 -fPIC 在加载动态库时，不用每次都在同一内存地址  -v 展示编译的详细过程信息  -ansi 支持ISO C89风格
-fsigned-char -funsigned-char 有符号和无符号的转化    -D 定义并调用命令宏  --Werror 将所有警告转变成错误  @file  file存储编译所需的参数

定义宏 #define CONT(x) #x
#取参数内容
定义宏  #define link(x,y) x##y
##用来连接两个参数 即x##y是xy

信号是由操作系统传给进程的中断，会提早终止一个程序。
signal(int signum, void (func*)(int)) 接受信号sig,并由func* 函数处理。 信号量定义在 <csignal>中

多线程
POSIX线程：
同步，又称直接制约关系，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。 
互斥，又称间接制约关系，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。
#include <pthread.h>
pthread_create (thread, attr, start_routine, arg)  //start_routine运行函数  arg运行函数参数
pthread_join(thread, return_status) 用来等待一个线程的结束，用于同步，若不结束，主线程一直阻塞，状态变为joinable
pthread_detach(thread_self) 状态变为unjoinable，如此一来，该线程运行结束后会自动释放所有资源，主线程不会被阻塞。
pthread_exit (status) 

公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。
cgicc-X.X.X

c++逆向工程分析工具：OllyDBG（调试器），PEid（PE文件分析，常见的EXE、DLL、OCX、SYS、COM都是PE文件，PE文件是微软Windows操作系统上的程序文件），IDA（反汇编静态分析工具）

可以看出静态成员函数的性质大体如下： 
*静态成员函数是类中特殊的成员函数 
*静态成员函数属于整个类所有 
*可以通过类名（作用域访问）直接访问公有静态成员函数 
*可以通过对象名访问公有静态成员函数
*静态成员函数不能访问普通成员变量（函数），需通过对象间接访问成员变量（函数） 

asni和unicode的主要区别，前者是单字节，后者是双字节。

webrtc传输sdp流程：offer先调用offerForConstraints得到自己的offerSdp，setLocalDescription(offerSdp)，把offerSdp发给远程answer，同时设置自己发送视频的最大码率。
answer收到offerSdp后，setRemoteDescription(offerSdp)。answerForConstraints得到自己的answerSdp，setLocalDescription(answerSdp)，把answerSdp发送给offer，同时设置自己发送视频的最大码率。
offer收到answerSdp后，setRemoteDescription(answerSdp)。
以上很多调用的WebRTC API都产生回调，回调可能返回错误，此时都要处理错误，一般就是把错误传递给上层，然后关闭整个会话。

实际网络请求底层接口：PhysicalSocket.cc

c++14 std::optional<T>  optional<T>内部存储空间可能存储了T类型的值也可能没有存储T类型的值，只有当optional被T初始化之后，这个optional才是有效的，否则是无效的，它实现了未初始化的概念。当函数会返回无效对象时，可以用这个。

c++11多线程如果std::promise对象在赋值之前被销毁，那么管理的std::future对象上的get()调用将会抛出异常。
除此之外，如果想要线程在不同时间点返回多个值，只需要在线程中传输多个std::promise对象，并从相关的多个std::futur对象中获取多个返回值

hash解决冲突的方法有：
1、线性探测 +1  2、二次探测  +1^2, +2^2, +3^2......  3、开链法   一个个bucket

开发一个新的nginx模块
1、编写config文件
2、定义module的结构体、定义ctx（各种时期回调函数）、定义commands（填充该模块conf）。
3、实现各种命令对应的handler

socket编程：发送端将本机的数据转换成网络的字节顺序（调用API函数htonl或htons），然后发送；接收端收到网络数据后，先将数据转换成本机的字节顺序（调用API函数ntohl或ntohs）。

ip fou将tcp加上udp信息，tcp包打成udp包

编译期限制栈大小，和系统限制栈深度根本是两回事。系统限制栈深是限制进程主线程的栈深，限制的是整个函数调用链的最大栈深，这个栈深是函数调用链上各个函数栈帧大小之和。编译期限制栈大小是限制单个函数栈帧的大小。
对于多线程程序来说，一个进程下的所有线程有自己独立的栈，但是堆是共享进程的堆。堆栈地址最大值×线程数目最大值<用户态内存地址最大值






